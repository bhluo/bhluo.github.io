<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Mysql Study Note | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="事务隔离级别 InnoDB 引擎它是支持事务 ，而旧版本的MySQL 使用的 MyISAM 引擎就不支持事务。 事务特性ACID:原子性** 一致性隔离性持久性**  持久性是通过 redo log （重做日志）来保证的；  原子性是通过 undo log（回滚日志） 来保证的；  隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；  一致性则是通过持久性+原子性+隔离性来保证； 一致性">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql Study Note">
<meta property="og:url" content="http://example.com/2024/03/24/sql/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="事务隔离级别 InnoDB 引擎它是支持事务 ，而旧版本的MySQL 使用的 MyISAM 引擎就不支持事务。 事务特性ACID:原子性** 一致性隔离性持久性**  持久性是通过 redo log （重做日志）来保证的；  原子性是通过 undo log（回滚日志） 来保证的；  隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；  一致性则是通过持久性+原子性+隔离性来保证； 一致性">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/1e37f6994ef44714aba03b8046b1ace2.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/68dd89fc95aa42cf9b0c4251d4e9226c-20230309222654910.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/8d1dfbab758fe7e4c58563fca9ccb6d4.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/90c1e01d0345de639e3426cea0390e80-20230309222252447.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png">
<meta property="article:published_time" content="2024-03-24T08:14:01.000Z">
<meta property="article:modified_time" content="2024-03-24T08:16:46.452Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-sql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/24/sql/" class="article-date">
  <time class="dt-published" datetime="2024-03-24T08:14:01.000Z" itemprop="datePublished">2024-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Mysql Study Note
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p> InnoDB 引擎它是支持事务 ，而旧版本的MySQL 使用的 MyISAM 引擎就不支持事务。</p>
<h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>ACID:<strong>原子性</strong>** 一致性<strong><strong>隔离性</strong></strong>持久性**</p>
<ul>
<li><p>持久性是通过 redo log （重做日志）来保证的；</p>
</li>
<li><p>原子性是通过 undo log（回滚日志） 来保证的；</p>
</li>
<li><p>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</p>
</li>
<li><p>一致性则是通过持久性+原子性+隔离性来保证；</p>
<p>一致性是由其他三个特性共同保证的。</p>
<span id="more"></span></li>
</ul>
<h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p><strong>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</strong></p>
<p>脏读：<strong>一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong>当事务B发生了回滚，那事务A读取的数据就是过期的。可以理解为领导还没下达正式任务你就凭着自己的揣摩开始干活，结果活干完了，任务的内容被改了。</p>
<h5 id="不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。（侧重于修改）"><a href="#不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。（侧重于修改）" class="headerlink" title="不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。（侧重于修改）"></a>不可重复读：<strong>一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong>（侧重于修改）</h5><h5 id="幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。（侧重于增删）"><a href="#幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。（侧重于增删）" class="headerlink" title="幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。（侧重于增删）"></a>幻读：<strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong>（侧重于增删）</h5><p>解决：</p>
<p>解决“不可重复读”只要加行级锁就可以了。而解决“幻读”则需要加表级锁，或者采用其他更复杂的技术，总之代价要大许多。隔离级别越高，并行度越低，付出的代价越大。</p>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ul>
<li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；可能发生脏读、不可重复读和幻读现象</li>
<li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；可能发生不可重复读和幻读现象</li>
<li>默认级别：<strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；比如事务中读取某条数据，只能看到和启动事务前一样的数据，事务提交后，才能看到新数据。可能发生幻读现象</li>
<li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；影响性能</li>
</ul>
<h2 id="可重复读如何工作的"><a href="#可重复读如何工作的" class="headerlink" title="可重复读如何工作的"></a>可重复读如何工作的</h2><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，解决的方案有两种：</p>
<p>1、针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
<p>2、针对<strong>当前读</strong>（select … for update 等语句），比如 update、insert、delete，是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</p>
<p><strong>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p>
<p>Read View 有四个重要的字段：</p>
<ul>
<li><p>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</p>
</li>
<li><p>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</p>
</li>
<li><p>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</p>
</li>
<li><p>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</p>
</li>
</ul>
<p>聚簇索引记录中的两个隐藏列<img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片"></p>
<p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列。</p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p>当前事务取访问记录时，只要记录的trx_id值大于readview中的max_trx_id，或位于min_trx_id和max_trx_id之间并且不在m_ids中的记录都对当前事务不可见。</p>
<p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p>
<h2 id="读提交是如何工作的："><a href="#读提交是如何工作的：" class="headerlink" title="读提交是如何工作的："></a>读提交是如何工作的：</h2><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p>
<p>每一次读取数据，都会生成readview，其中活跃事务和id最小&#x2F;最大事务都可能会更新。假设事务a的id小于b，所以一旦事务a提交了，事务b就能读取到a提交的数据，因为a不在b中readview的活跃事务id中</p>
<p>在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li><p>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
</li>
<li><p>「可重复读」隔离级别是启动事务时（执行 begin 语句后）生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</p>
<p>执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p>
<ul>
<li>第一种：begin&#x2F;start transaction 命令；</li>
<li>第二种：start transaction with consistent snapshot 命令；</li>
</ul>
<p>这两种开启事务的命令，事务的启动时机是不同的：</p>
<ul>
<li><p>执行了 begin&#x2F;start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才会真正启动事务，并生成对应的读视图（readview）。</p>
</li>
<li><p>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</p>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
</li>
</ul>
</li>
</ul>
<p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p>
<h1 id="锁篇"><a href="#锁篇" class="headerlink" title="锁篇"></a>锁篇</h1><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/1e37f6994ef44714aba03b8046b1ace2.png" alt="img"></p>
<p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li><p>对数据的增删改操作，比如 insert、delete、update等语句；</p>
</li>
<li><p>对表结构的更改操作，比如 alter table、drop table 等语句。</p>
<p>解开锁常见方式：</p>
</li>
</ul>
<p>1、手动释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>2、会话断开了，全局锁会被自动释放。</p>
<p>3、如果有一个事务持有了全局锁，通过提交（COMMIT）或回滚（ROLLBACK）该事务来释放全局锁。</p>
<p>4、等待锁超时：</p>
<p> 全局锁主要应用于做<strong>全库逻辑备份</strong> </p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li><p>表锁；</p>
</li>
<li><p>元数据锁（MDL）;</p>
</li>
<li><p>意向锁；</p>
</li>
<li><p>AUTO-INC 锁；</p>
<p><strong>表锁</strong>。</p>
<p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>再来说说<strong>元数据锁</strong>（MDL）。</p>
<p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<blockquote>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
</blockquote>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<blockquote>
<p>为什么某线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p>
</blockquote>
<p>这是因为申请 MDL 锁的操作会形成一个<strong>队列</strong>，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="#意向锁"></a><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/lock/mysql_lock.html#%E6%84%8F%E5%90%91%E9%94%81">#</a>意向锁</h3><ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</p>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><p>事务 A 先获取了某一行的<strong>排他锁</strong>，并未提交：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id = 6 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<ol>
<li>事务 A 获取了 users 表上的<strong>意向排他锁</strong>。</li>
<li>事务 A 获取了 id 为 6 的数据行上的<strong>排他锁</strong>。</li>
</ol>
<p>之后事务 B 想要获取 users 表的<strong>共享锁</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES users READ;</span><br></pre></td></tr></table></figure>

<ol>
<li>事务 B 检测到事务 A 持有 users 表的<strong>意向排他锁</strong>。</li>
<li>事务 B 对 users 表的加锁请求被阻塞（排斥）。</li>
</ol>
<p>最后事务 C 也想获取 users 表中某一行的<strong>排他锁</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id = 5 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<ol>
<li>事务 C 申请 users 表的<strong>意向排他锁</strong>。</li>
<li>事务 C 检测到事务 A 持有 users 表的<strong>意向排他锁</strong>。</li>
<li>因为意向锁之间并不互斥，所以事务 C 获取到了 users 表的<strong>意向排他锁</strong>。</li>
<li>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终事务 C 成功获取到了该数据行上的<strong>排他锁</strong>。</li>
</ol>
<h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="#AUTO-INC 锁"></a><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/lock/mysql_lock.html#auto-inc-%E9%94%81">#</a>AUTO-INC 锁</h3><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁的类型主要有三类：</p>
<ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<p>记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p>
<p>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，</p>
<p>在读已提交隔离级别下，行级锁的种类只有<strong>记录锁</strong>，也就是仅仅把一条记录锁上。</p>
<p>在可重复读隔离级别下，行级锁的种类除了有<strong>记录锁，还有间隙锁</strong>（目的是为了避免幻读）</p>
<p>next-key lock 在一些场景下会退化成记录锁或间隙锁。</p>
<p>那到底是什么场景呢？总结一句，<strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong>。</p>
<ul>
<li>查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。（只锁该行数据）</li>
<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。（防止其他事务插入未存在索引的数据，就能避免幻读）</li>
</ul>
<p>不管是不是非唯一索引，还是唯一索引进行锁定读查询的时候</p>
<p>除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」。</p>
<p> update 语句的where 带上索引就能避免全表记录加锁了吗？ </p>
<p>并不是。</p>
<p><strong>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了</strong>。</p>
<p>所以 当我们要执行 update 语句的时候，确保 where 条件中带上了索引列，并且在测试机确认该语句是否走的是索引扫描，防止因为扫描全表，而对表中的所有记录加上锁。 如果发现即使在 where 条件中带上了列索引列，优化器走的还是全标扫描，这时我们就要使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引。</p>
<p>如果事务 A的 update 语句中 where 条件没有索引列，触发了全表扫描，在扫描过程中会对索引加锁</p>
<p>如果对 age 建立索引，事务 A 这条查询会加什么锁呢？<img src="https://cdn.xiaolincoding.com//mysql/other/68dd89fc95aa42cf9b0c4251d4e9226c-20230309222654910.png" alt="img"></p>
<p> <strong>因为表中有两个索引，分别是主键索引和 age 索引，所以会分别对这两个索引加锁。</strong> </p>
<p>主键索引会加如下的锁：</p>
<ul>
<li>X 型的记录锁，锁住 id &#x3D; 2 的记录；</li>
<li>X 型的记录锁，锁住 id &#x3D; 3 的记录；</li>
<li>X 型的记录锁，锁住 id &#x3D; 5 的记录；</li>
<li>X 型的记录锁，锁住 id &#x3D; 6 的记录；</li>
<li>X 型的记录锁，锁住 id &#x3D; 7 的记录；</li>
<li>X 型的记录锁，锁住 id &#x3D; 8 的记录；</li>
</ul>
<p>age 索引加的锁：</p>
<ul>
<li>X 型的 next-key lock，锁住 age 范围 (19, 21] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (21, 21] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (21, 23] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (23, 23] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (23, 39] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (39, 43] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (43, +∞] 的记录；</li>
</ul>
<p>可以看到，对 age 字段建立了索引后，查询语句是索引查询，并不会全表扫描，因此<strong>不会把整张表给锁住</strong>。</p>
<p>如果 age 字段没有建立了索引，会导致全表扫描，将整张表锁住。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/8d1dfbab758fe7e4c58563fca9ccb6d4.png" alt="图片"></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/90c1e01d0345de639e3426cea0390e80-20230309222252447.png" alt="img"></p>
<p>当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id &#x3D; 1008 的记录就会被锁住：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> t_order (order_no, create_date) <span class="keyword">values</span> (<span class="number">1008</span>, now());</span><br></pre></td></tr></table></figure>

<p>因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁，<strong>而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 <code>select ... for update</code> 语句并不会相互影响</strong>。</p>
<p>案例中的事务 A 和事务 B 在执行完后 <code>select ... for update</code> 语句后都持有范围为<code>(1006,+∞]</code>的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。</p>
<blockquote>
<h2 id="为什么间隙锁与间隙锁之间是兼容的？"><a href="#为什么间隙锁与间隙锁之间是兼容的？" class="headerlink" title="为什么间隙锁与间隙锁之间是兼容的？"></a>为什么间隙锁与间隙锁之间是兼容的？</h2></blockquote>
<p>在MySQL官网上还有一段非常关键的描述：</p>
<p><strong>间隙锁的意义只在于阻止区间被插入</strong>，因此是可以共存的。<strong>一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁</strong>，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。</p>
<p>这里的共同间隙包括两种场景：</p>
<ul>
<li>其一是两个间隙锁的间隙区间完全一样；</li>
<li>其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。</li>
</ul>
<p>但是有一点要注意，<strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系。X 型的记录锁与 X 型的记录锁是冲突的，比如一个事务执行了 select … where id &#x3D; 1 for update，后一个事务在执行这条语句的时候，就会被阻塞的。</p>
<p>但是还要注意！对于这种范围为 (1006, +∞] 的 next-key lock，两个事务是可以同时持有的，不会冲突。因为 +∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系。</p>
<p>​		每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态</p>
<p>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。</p>
<ul>
<li>如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li>
<li>如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</li>
</ul>
<p>并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。</p>
<p>但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会<strong>被阻塞</strong>，<strong>因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的</strong>，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。</p>
<h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p>
<p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p>
<ul>
<li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p>
<p>当发生超时后，就出现下面这个提示：</p>
</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png" alt="图片"></p>
<ul>
<li><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>inno</code></li>
</ul>
<p>当检测到死锁后，就会出现下面这个提示：<img src="https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png" alt="图片"></p>
<p>最后说个段子：</p>
<p>面试官: 解释下什么是死锁?</p>
<p>应聘者: 你录用我,我就告诉你</p>
<p>面试官: 你告诉我,我就录用你</p>
<p>应聘者: 你录用我,我就告诉你</p>
<p>面试官: 卧槽滚！</p>
<p>（陷入循环，不告诉就不录用，不录用就不告诉）</p>
<p>如果update不存在的数据，会生成一个意向x表锁，并会生成一个间隙锁。</p>
<p>如果update一个范围，而范围内数据，则空范围会有间隙锁，数据行加x型的记录锁，即这个范围内加了next-key lock。</p>
<p> 两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。 </p>
<p>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</p>
<p>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁</p>
<h1 id="mysql锁篇完结，撒花花"><a href="#mysql锁篇完结，撒花花" class="headerlink" title="mysql锁篇完结，撒花花~~"></a>mysql锁篇完结，撒花花~~</h1><h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><p> 要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。 <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png" alt="img"></p>
<p>Buffer Pool以页为单位，默认大小为16KB。Mysql启动后，InnoDB会为pool申请一片连续的内存空间，然后按16KB划分成一个个页。但虚拟内存被访问后，操作系统出发缺页中断，将虚拟内存和物理内存建立映射。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/03/24/sql/" data-id="clu58w4tm0000xoeobpbu8d8w" data-title="Mysql Study Note" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/note/" rel="tag">note</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/03/21/first-blog-in-2024/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">first blog in 2024</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/jekyll-update/">jekyll update</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mood-note/">mood note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note-maven/">note maven</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">note</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/note/" style="font-size: 10px;">note</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/03/24/sql/">Mysql Study Note</a>
          </li>
        
          <li>
            <a href="/2024/03/21/first-blog-in-2024/">first blog in 2024</a>
          </li>
        
          <li>
            <a href="/2023/10/20/2023-20-20-MavenNotes/">Study Notes of Maven</a>
          </li>
        
          <li>
            <a href="/2023/10/12/2023-10-12-FirstBlog/">My first site</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>